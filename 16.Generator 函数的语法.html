<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Generator 函数的语法</title>
</head>

<body>
    <script>
        /* 1.简介 */
        /* Generator函数的语法和API
            语法理解:Generator函数是一个状态机,封装了多个内部状态
            执行generator返回一个遍历器对象.generator函数除了状态机,还是一个遍历器对象生成函数.返回的遍历器对象,可以依次遍历generator函数的每一个状态
         */
        /* 形式上generator函数是一个普通函数,两个特征:
           1.function关键字与函数名之间有个*号
           2.函数体内部使用yield表达式,定义不同的内部状态.yield的意思就是产出.
         */
        {
            function* helloWorldGenerator() {
                yield 'hello'
                yield 'world'
                return 'ending'
            }
            var hw = helloWorldGenerator()
            /* generator函数调用之后不执行,返回的也不是函数的运行结果,而是指向内部状态的指针对象,也就是遍历器对象(Iterator Object) */
            /* 下一步,必须调用遍历器对象的next方法,让指针指向下一个状态 
                每次调用next方法,内部指针就从头部函数或上一次停下来的地方开始执行,知道遇到下一个yield或者return语句   
            */
            /* Generator函数是分段执行,yield是暂停执行的标志,next方法可以恢复执行 */
            // console.log(hw.next())
            // {value: "hello", done: false}

            // console.log(hw.next())
            //{ value: "world", done: false }

            // console.log(hw.next())
            //{ value: "ending", done: true }
            //在第三次执行,next方法返回的对象的value属性,紧跟着return语句后面表达式的值(如果没有return语句,则value属性值Wieundefined),done属性为true,表示结束

            // console.log(hw.next())
            //{ value: undefined, done: true }

            /* 从上往下依次执行,每次next都执行一次,value就是当前yield的值,done就是遍历是否执行完成 */
        }
        /* generator函数就返回一个遍历器的对象,代表generator函数的内部指针.每次调用next方法,就会有个有着value和done两个属性的对象返回
            value:当前内部状态的值 yield/return表达式的值
            done:表里是否结束
         */
        {
            /* 声明方式 */
            function* foo1() { }
            function* foo2() { }
            function* foo3() { }
            function* foo4() { }
            /* es6没有规定,因此上面四种方式都可以通过 */
        }

        /* yield表达式 */
        //  generator函数返回的是遍历器对象,调用next方法才会遍历下一个内部状态,提供了可以暂停执行的函数,yield就是暂停的标志
        /* next的运行逻辑
            遇到yield,暂停操作,返回yield后面的值
            下次调用next,再继续往下执行,直到遇到下一个yield
            如果没有遇到新的yield,一直运行到函数结束,直到return语句,并且返回return后面表达式的值 
            如果该函数没有return语句,则返回对象的value为undefined        
         */
        /* yield后面值只有调用next才会执行,js是惰性求值(Lazy Evaluation) */
        {
            function* gen() {
                yield 123 + 456
            }
            let g = gen()
            // console.log(g.next())// 579 false
            // console.log(g.next())// undefined true
        }
        /* yield和return
            相同:返回紧跟着后面的表达式的值
            区别:yield有记忆功能,函数暂停或运行,下次再从该位置继续往后执行
                return没有记忆功能,只能执行一次return,而可以多次执行yield.
            
            generator可以通过yield返回一系列的值,generator--生成器
         */
        /* Generator函数不用yield表大四,成了暂缓执行函数 */
        {
            function* f() {
                console.log('执行了')
            }
            let g = f()
            setTimeout(() => {
                // g.next()
                // 成了暂缓函数
            }, 2000);
        }
        /* 同时 yield表达式只能用在generator函数里面,否则报错 */
        {
            (function () {
                // yield 1
                // error
            })();
        }
        /* 另一种例子 */
        {
            var arr = [1, 2, 3, 4, [8, 9]];
            var flat = function* (a) {
                a.forEach(item => {
                    if (typeof item !== 'number') {
                        // yield * flat(item)
                    } else {
                        // yield item
                        // 报错 forEach方法的参数是一个普通函数,里面不能放yield
                    }
                })
            }
            for (var f of flat(arr)) {
                console.log(f)
            }
        }
        /* 修改后的方法  改用for循环 */
        {
            var arr = [1, 2, 3, 4, [8, 9]];
            var flat = function* (a) {
                for (let i = 0; i < a.length; i++) {
                    const element = a[i];
                    if (typeof element !== 'number') {
                        yield* flat(element)
                    } else {
                        yield element
                    }
                }
            }
            for (var f of flat(arr)) {
                // console.log(f) //1 2 3 4 8 9
            }
        }
        /* 如果yield表达式用在另一个表达式,就需要放在圆括号里面 */
        {
            function* demo() {
                // console.log(1+ yield) //error 
                // console.log(1+ yield 1) /error
                // console.log(1+ (yield))
                // console.log(1+ (yield 1))
            }
            demo()
        }
        /* yield表达式用作函数参数放在赋值表达式右边,可以不加括号 */
        {
            const foo = () => { }
            function* demo() {
                foo(yield 'a', yield 'b');
                let input = yield
            }
        }

        /* 与ITterator 接口的关系 */
        /* 任意一个对象的Symbol.literator方法,等于该对象的遍历器生成函数,
        调用该函数会返回该对象的遍历器对象
            由于Generator函数就是遍历器生成函数,因此可以把generator赋值给对象的symbol.iterator属性,从而使得该对象具有iterator接口
         */
        {
            var myIterator = {};
            myIterator[Symbol.iterator] = function* () {
                yield 1;
                yield 2;
                yield 3;
            }
            // console.log([...myIterator]) // [1,2,3]
            /* generator函数赋值给 Symbol.iterator,从而使得myIterator对象有了Iterator接口,可以被...遍历*/
        }
        /* generator函数执行之后,返回一个遍历器的对象,该对象本身也具有Symbol.iterator属性,执行之后返回自身 */
        {
            function* gen() {
                yield 1
            }
            var g = gen();
            // 执行之后返回自身
            // console.log(g[Symbol.iterator]() === g)
            /* gen是一个Generator函数,调用会生成一个遍历器对象g,g的Symbol.iterator属性也是一个遍历器对象生成函数,执行之后返回自己 */
        }

        /* next方法的参数 */
        /* yield表达式本身没有返回值,或者总是返回undefined.next方法可以带一个参数,该参数会被当做上一个yield表达式的返回值  类似于python生成器的__send__()函数 */
        {
            function* f() {
                for (var i = 0; 1; i++) {
                    var reset = yield i;
                    if (reset) {
                        i = -1;
                        // return
                    }
                }
            }
            var g = f();
            /* 如果没有return语句,一直在for循环循环  那个0是-1加1的加过 */
            // console.log(g.next())//{value: 0, done: false}
            // console.log(g.next())//{value: 1, done: false}
            // console.log(g.next())//{value: 2, done: false}
            // console.log(g.next(true))//{value: 0, done: false}
            // console.log(g.next(true))//{value: 0, done: false}
            // console.log(g.next(true))//{value: 0, done: false}

            /* 如果有return语句,一直在for循环循环  undefined是没有任何返回值的结果 */
            // console.log(g.next())//{value: 0, done: false}
            // console.log(g.next())//{value: 1, done: false}
            // console.log(g.next())//{value: 2, done: false}
            // console.log(g.next(true))//{value: undefined, done: false}
            // console.log(g.next(true))//{value: undefined, done: false}
            // console.log(g.next(true))//{value: undefined, done: false}

            /* 这个功能很有语法意义,generator函数从暂停状态到恢复运行,它的上下文状态(context)是不变的.
            通过next方法的参数,就有办法在generator函数的开始运行之后继续向函数体内部注入值.也就是说,可以在generator
            */
        }
        {
            function* foo(x) {
                var y = 2 * (yield (x + 1))
                var z = yield (y / 3)
                return (x + y + z)
            }
            var a = foo(5)
            // console.log(a.next()) // 6 false
            // console.log(a.next()) // NaN false
            // console.log(a.next()) // NaN false
            var b = foo(5)
            // console.log(b.next()) // 6 false
            // console.log(b.next(12)) // 8 false  --2*12/3
            // console.log(b.next(13)) // 42 false --5+2*12+13
        }
        /* 第一个next传参是无效的,v8会自动忽略,从第二个开始才是有效的 */
        {
            function* dataConsumer() {
                // console.log('started'); //start
                // console.log(`1.${yield}`) // 1.a
                // console.log(`2.${yield}`) // 2.b
                return 'result'
            }
            let genObj = dataConsumer();
            // console.log(genObj.next()) //{value: undefined, done: false}
            // console.log(genObj.next('a')) //{value: undefined, done: false}
            // console.log(genObj.next('b')) //{value: "result", done: true}
            // 在yield要暂停一下,要看yield有没有值
        }
        /* 如果想要在第一次调用next方法时就可以输入值,可以在generator函数外面包一层 */
        {
            function wrapper(generatorFunction) {
                return function (...args) {
                    let generatorObject = generatorFunction(...args);
                    // 相当于先走一步next,下一次next的时候就可以赋值了
                    generatorObject.next();
                    // 返回的是可迭代对象
                    return generatorObject;
                }
            }
            // wrapped其实是里面的匿名函数
            const wrapped = wrapper(function* () {
                console.log(`first input ${yield}`);
                return 'done';
            })
            // console.log(wrapped().next('hello'))
        }

        /* for of 循环 */
        /* for of可以自动遍历Generator函数生成的Iterator对象,而且不需要执行next方法 */
        {
            function* foo() {
                yield 1
                yield 2
                yield 3
                yield 4
                return 5
            }
            a = foo()
            // console.log(a.next())//{value: 1, done: false}
            // console.log(a.next())//{value: 2, done: false}
            // console.log(a.next())//{value: 3, done: false}
            // console.log(a.next())//{value: 4, done: false}
            /*   // 下面done会变为true 就停止执行 */
            // console.log(a.next())//{value: 5, done: true}
            for (const i of foo()) {
                // console.log(i)
                //1 2 3 4
            }
        }
        /* 一旦next方法返回的对象的done属性为true,for of的循环就会终止,而且不返回该对象,所以上面的return的6不在范围内 */
        /* generator函数 + for of实现斐波那契数列 */
        {
            function* fibonacci() {
                let [prev, curr] = [0, 1]
                let count = 0;//轮数
                for (; ;) {
                    count++
                    yield { curr, count };
                    [prev, curr] = [curr, curr + prev]
                }
            }
            for (let n of fibonacci()) {
                if (n.curr > 14) break;
                // console.log(n);
            }
        }
        /* 利用for of循环,可以写出任意对象object的方法,原生的对象没有便利借口,无法使用for of循环.通过generator函数为其增加接口 */
        {
            function* objectEntries(obj) {
                // https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect/ownKeys
                let propsKeys = Reflect.ownKeys(obj);
                for (const propKey of propsKeys) {
                    yield [propsKeys, obj[propsKeys]]
                }
            }
            let jane = {
                first: 'Jane',
                last: 'Doe'
            }
            for (const [key, value] of objectEntries(jane)) {
                // console.log(key, value)
            }
            /* 加上遍历器接口的另一种写法是,将Generator函数加到对象的Symbol.Iterator属性上面 */
        }
        {
            function* objectEntries() {
                let propKeys = Object.keys(this)
                for (const propKey of propKeys) {
                    yield [propKey, this[propKey]]
                }
            }
            let jane = {
                first: 'Jane',
                last: 'Doe'
            }
            jane[Symbol.iterator] = objectEntries;
            for (const [key, value] of jane) {
                // console.log(key, value)
            }
        }
        /* 除了for...of循环,扩展运算符...,解构赋值,Array.from方法内部调用,都是遍历器接口.=>他们都可以将generator函数返回的iterator对象作为参数 */
        {
            function* numbers() {
                yield 1
                yield 2
                return 3
                yield 4
            }
            /* 拓展运算符 */
            // console.log([...numbers()])//[1, 2]
            /* array.from */
            // console.log(Array.from(numbers())) //[1,2]
            /* 解构赋值 */
            let [x,y]=numbers()
            // console.log(x,y) // 1 2
            /* for of */
            for (const n of numbers()) {
                // console.log(n) // 1 2 
            }
        }


        /* Generator.prototype.throw() */

    </script>
</body>

</html>
